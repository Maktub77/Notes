##### oo基础

* 抽象
* 封装
* 多态
* 继承

##### oo原则

* 封装变化
* 多用组合，少用继承
* 针对接口编程，不针对实现编程
* 为交互对象之间的松耦合设计而努力
* 对扩展开放，对修改关闭
* 依赖抽象，不要依赖具体——依赖倒置原则
  * 变量不可以持有具体类的引用
    * 如果使用new，就会持有具体类的引用，你可以改用工厂来避免这样的做法
  * 不要让类派生自具体类
    * 如果派生自具体类，你就会依赖具体类，请派生自一个抽象（接口或抽象类）
  * 不要覆盖基类中已实现的方法
    * 如果覆盖已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享
* 最少只是原则——只和朋友交谈
* 好莱坞原则——被找我，我会找你
  * 由超类主控一切，当他们需要的时候，自然会去调用子类
* 类应该只有一个改变的理由

##### oo模式

* 策略模式——定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
* 观察者模式——在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新
* 装饰者模式——动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。
* 抽象工厂模式——提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
* 工厂方法模式——定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类
* 单例模式——确保一个类只有一个实例，并提供全局访问点
* 命令模式——将请求封装成对象，这可以让你使用不同的请求、队列、或者日志请求来参数化其他对象。命令模式也可以支持撤销操作（当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式）
* 适配器模式——将一个类的接口，转换成客户期望的另一个接口，适配器让原本不兼容的类可以合作无间
* 外观模式——提供了一个统一的接口，用来访问子系统中的一群接口
* 模板方法模式——在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤
* 迭代器模式——提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示
* 组合模式——允许你将对象组成树形结构来表现“整体/部分”的层次结构。组合能让客户以一致的方式处理个别对象和对象组合
* 状态模式——允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
* 代理模式——为另一个对象提供一个替身或占位符以访问这个对象

----

内聚（cohesion）：用来度量一个类或模块紧密地达到单一目的或责任

当一个模块或一个类被设计成只支持一组相关的功能时，我们说他具有高内聚；反之，当设计成支持一组不相关的功能时，我们说他具有低内聚

内聚是一个比单一责任原则更普遍的概念，但两者其实关系是很密切的。遵守这个原则的类容易具有很高的凝聚力，而且比背负许多责任的地内聚更容器维护

---

策略——封装可互换的行为，并使用委托决定使用哪一个

适配器——改变一个或多个类的接口

迭代器——提供一个方式来遍历集合，而无需暴露集合的实现

外观——简化一群类的接口

组合——客户可以将对象的集合以及个别对象一视同仁

观察者——当某个状态改变时，允许一群对象能被通知到

----



