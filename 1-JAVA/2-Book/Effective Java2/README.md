## [Effective Java3](https://www.jianshu.com/p/bcbf22d00823)

### Effective Java

1. 考虑使用静态工厂方法替代构造方法
2. 当构造方法参数过多时使用builder模式
3. 使用私有构造方法或枚举类实现Singleton属性
4. 使用私有构造方法执行非实例化
5. 使用依赖注入取代硬连接资源
6. 避免创建不必要的对象
7. 消除过期的对象引用
8. 避免使用Finalizer和Cleaner机制
9. 使用try-with-resources语句替代try-finally语句
10. 重写equals方法时遵守通用约定
11. 重写equals方法时同样也要重写hashcode方法
12. 始终重写toString方法
13. 谨慎地重写clone方法
14. 考虑实现Comparable接口
15. 使类和成员的可访问性最小化
16. 在公共类中使用访问方法而不是公共属性
17. 最小化可能性
18. 组合优于继承
19. 如果使用继承则设计，并文档说明，否则不该使用
20. 接口优于抽象类
21. 为后代设计接口
22. 接口仅用来定义类型
23. 优先使用类层次而不是标签类
24. 优先考虑静态成员类
25. 将源文件限制为单个顶级类
26. 不要使用原始类型
27. 清楚非检查警告
28. 列表优于数组
29. 优先考虑泛型
30. 优先使用泛型方法
31. 使用限定通配符来增加API的灵活性
32. 合理地结合泛型和可变参数
33. 优先考虑类型安全的异构容器
34. 使用枚举类型替代整型常量
35. 使用实例属性替代序数
36. 使用EunmSet替代位属性
37. 使用EnumMap替代序数索引
38. 使用接口模拟可扩展的枚举
39. 注解优于命名模式
40. 始终使用Override注解
41. 使用标记接口定义类型
42. lambda表达式优于匿名类
43. 方法引用优于lambda表达式
44. 优先使用标准的函数式接口
45. 明智谨慎地使用Stream
46. 优先考虑流中无副作用的函数
47. 优先使用Collection而不是Stream来作为方法的返回类型
48. 谨慎使用流并行
49. 检查参数有效性
50. 必要时进行防御性拷贝
51. 仔细设计方法签名

-----

* 清晰性和简洁性
* 模块的用户