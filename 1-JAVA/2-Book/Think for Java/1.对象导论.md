​	“我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来... ...除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。”

* 将对象想象为"服务提供者"

* 使用现有的类合成新的类，所以这种概念被称为组合（composition）,如果组合是动态发生的，那么他通常被称为聚合（aggregation）。

* 组合 --- 继承

* 可以创建一个基类来表示系统中的核心概念，从基类中导出其他类型，来表示此核心可以被实现的各种不同方式。

* 应该仔细考虑是否存在基类也需要这些额外方法的可能性。

* 判断是否**继承**，就是要确定是否可以用is-a来描述类之间的关系，并使其具有实际意义

* 通过导出新的子类型而轻松扩展设计的能力是对改动进行封装的基本方式之一。

* **后期绑定**：当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查（无法提供此类保证的语言被称为是弱类型的），但是并不知道将被执行的确切代码。

* **单根继承结构**保证所有对象都具备某些功能。从而不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要，并且给编程带来了更大的灵活性。

* 容器：在任何需要是都可以扩充自己以容纳你置于其中的所有东西。

* 我们可以在一开始使用`LinkedList`构建程序，而在优化系统性能时改用`ArrayList`.

* 参数化类型（泛型）就是一个编译器可以自动定制作用于特定类型上的类。

* Java完全采用了**动态内存分配方式**。每当想要创建新对象时，就要使用new关键字来构建此对象的动态实例。

* 只能以一种方式创建对象（在堆上创建）

* 把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程。

* 可以共享的资源，必须在使用期间被锁定。

  过程：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。

---

客户/服务器系统的核心思想：

* 系统具有一个中央信息存储池(central repository of information)，用来存储某种数据，它通常存在于数据库中，你可以根据需要将它分发给某些人员或机器集群。
* 客户/服务器概念的关键在于信息存储池的位置集中于中央，这使得它可以被修改，并且这些修改将被传播给信息消费者。
* 信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或机群被总称为服务器。
* 驻留在用户机器上的软件与服务器进行通信，以获取信息、处理信息，然后将他们显示在被称为客户机的用户机器上。
* 系统通常允许客户在服务器中插入新的信息。这意味着必须保证一个卡户出入的新数据不会覆盖另一个客户插入的新数据，也不会在将其添加到数据库的过程中丢失（事务处理）。

----

1. **万物皆为对象。**将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件，将其表示为程序中的对象。
2. **程序是对象的集合，它们通过发送消息来告知彼此所要做的。**要想请求一个对象，就必须对该对象发送一条消息。更具体地说，可以把消息想象为对某个特定对象的方法的调用请求。
3. **每个对象都有自己的由其他对象所构成的存储。**就是可以通过构建现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。
4. **每个对象都拥有其类型**。按照通用的说法，“每个对象都是一个类（class）的一个实例（instance）”，这里“类”就是“类型”的同义词。每个类最重要的区别于其他类的特征就是“可以发送什么消息给它”。
5. **某一特定类型的所有对象都可以接收同样的消息。** 如果这类事物可以完成某项功能，代表这类事物中的个体都可以完成这项功能。这种可替代性（substitutability）是OOP中强有力的概念之一。

---

* 对象具有**状态、行为和标识**。这意味着每一个对象都可以拥有内部数据（它们给出了该对象的状态）和方法（它们产生行为），并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。

---

每个对象都有一个接口

每个对象都是服务提供者

* 程序本身就是向用户提供服务，它通过调用其他对象提供的服务来实现这一目的。
* 目标就是创建（或者最好是在现有代码库中寻找）能够提供理想的服务来解决问题的一系列对象。
* 将问题分解为对象集合
  * 在表象中抽取出来什么样的对象可以马上解决我的问题？
  * 某些对象已经存在，但是不存在的对象，它们应该是什么样子？它们能够提供哪些服务？它们需要哪些对象才能履行它们的义务？
* **在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事。**

隐藏的具体实现

* 访问控制：让客户端程序员无法触及他们不应该触及的部分；允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。

复用具体实现

* 在建立新类时，应该首先考虑组合。

继承

伴随多态的可互换对象

* 一个非面向对象编程的编译器产生的函数调用会引发所谓的**前期绑定**，也就是说编译器将产生对一个具体函数名字的调用，而运行时将这个调用解析到将要被执行的代码的绝对地址。
* **后期绑定**：当向对象发送消息时，被调用的代码直到运行时才能确定。

---

并发编程：同一时刻处理多个任务的思想

* 问题：共享资源
* 解决：某个任务锁定某个资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源

---

* 客户/服务器系统的核心思想：信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或集群被总称为服务器。

* 问题：单一的服务器，同时为多个客户服务

  ​	通常，这会涉及数据库管理系统，因此设计者把数据"均衡"分布于数据表中，以取得最优的使用效果。

  ​	此外，系统通常允许客户在服务器中插入新的信息。这意味着必须保证一个客户插入的新数据不会覆盖另一个客户插入的新数据，也不会在将其添加到数据库的过程中丢失（事务处理）。

* 性能问题：

  * 减轻处理任务的负载，通常是分散给客户端机器处理
  * 使用**中间件**将负载分散给在服务器端的其他机器.(中间件也被用来提高可维护性

>CGI（通用网关接口）：一段运行在服务器上，提供同客户端HTML页面的接口的一段程序。

