运行时类型信息使得你可以在程序运行时发现和使用类型信息。

* Java是如何让我们在运行时识别对象和类的信息的。

  * 主要有两种方式：
    1. “传统的”**RTTI**(Run-Time Type Information)，它假定我们在编译时已经已经知道了所有的类型；
    2. “**反射**”机制，它允许我们在运行时发现和使用类的信息。

* 所有的类都是在对其第一次使用时，动态加载到JVM中的。

* Class对象就和其他对象一样，我们可以获取并操作它的引用（这也是类加载器的工作）。

* Class的`newInstance()`方法是实现“虚拟构造器”的一种途径，虚拟构造器允许你声明：“我不知道你的确切类型，但是无论如何要正确地创建你自己。”

* Java还提供了另一种方法来生成对Class对象的引用，即使用类字面常量。

  ```java
  FancyToy.class;
  ```

* 建议使用“.class”的形式，以保持与普通类的一致性。

* 注意，当使用“.class”来创建对Class对象的引用时，不会自动地初始化该Class对象。

  为了使用类而做的准备工作：

  1. **加载**，这是由类加载器执行的。查找字节码，并从字节码中创建一个Class对象。
  2. **链接**，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。
  3. **初始化**，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。

* 设计模式的关键就是封装修改——因此你需要修改事物以证明这种模式的正确性

* Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态地创建代理并动态地处理对所有代理方法的调用。

  在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。
