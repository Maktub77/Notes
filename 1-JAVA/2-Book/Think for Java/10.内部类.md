可以讲一个类的定义放在另一个类的定义内部，这就是内部类。

* 当生成一个内部类的对象时，此对象与制造它的外围对象（enclosing object）之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。
* 匿名内部类：创建一个继承自父类的匿名类的对象。通过new表达式返回的引用被自动向上转型为父类的引用。
* 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
* 特性：
  1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
  2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
  3. 创建内部类对象的时刻并不依赖于外围类对象的创建。
  4. 内部类并没有令人迷惑的“is-a”关系；它就是一个独立的实体。

* **闭包**（closure）：是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。
* 内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有成员，包括private成员。

---

软件模块之间接口的调用

* 同步调用：同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用

  ![img](https://images2015.cnblogs.com/blog/801753/201702/801753-20170221201001413-1766758208.png)

* **回调**（callback）：双向调用

  * 类A的a()方法调用类B的b()方法

  * 类B的b()方法执行完毕主动调用类A的callback()方法

    ![img](https://images2015.cnblogs.com/blog/801753/201702/801753-20170221205712070-824897248.png)

* 异步调用：类A的方法方法a()通过新起线程的方式调用类B的方法b()，代码接着直接往下执行

  ![img](https://images2015.cnblogs.com/blog/801753/201702/801753-20170221201512429-1532730453.png)

* 回调的价值在于它的灵活性——可以在运动时动态地决定需要调用什么方法。

----

* 主要用来响应时间的系统被称作**事件驱动系统**。