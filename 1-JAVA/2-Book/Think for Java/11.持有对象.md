如果一个程序值包含固定数量的且其生命周期都是已知的对象，那么这就是一个非常简单的程序。

* 迭代器(也是一种设计模式)：迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代器通常被称为轻量级对象：创建它的代价小。

  Java的迭代器只能单向移动

  1. 使用方法iterator()要求容器返回一个Iterator.Iterator将准备好返回序列的第一个元素。
  2. 使用next()获得序列中的下一个元素。
  3. 使用hasNext()检查序列中是否还有元素。
  4. 使用remove()将迭代器新近返回的元素删除。

> 迭代器模式：就是提供一种方法对容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。

* 栈（Stack）通常是指“先进后出(LIFO)”的容器。有时栈也被称为叠加栈，因为最后“压入”栈的元素，第一个“弹出”栈。

* 队列(Queue)是一个典型的“先进先出(FIFO)”的容器。即从容器的一端放入事物，从宁一段取出，并且事物放入容器的顺序与取出的顺序是相同的。队列常被当作一个可靠的将对象从程序的某个区域传输到另一个区域的途径。
* 优先级队列(PriorityQueue)

总结：

* Java提供了大量持有对象的方式：
  1. 数组将数字与对象联系起来。它保持类型明确的对象，查询对象时，不需要对结果做类型转换。它可以是多维的，可以保存基本数据类型。但是，数组一旦生成，其容量就不能改变。
  2. Collection保存单一元素，而Map保存相关联的键值对。有了Java的泛型，你就可以指定容器中存放的对象类型，因此你就不会将错误的类型的对象放置到容器中，并且在从容器中获取元素时，不必进行类型转换。各种Collection和各种Map都可以在你向其中添加更多的元素时，自动调整其尺寸。容器不能持有基本类型，但是自动包装机制会仔细地执行基本类型到容器中所持有的包装器类型之间的双向转换。
  3. 像数组一样，List也建立数字索引与对象的关联，因此，数组和List都是排好序的容器。List能够自动扩充容量。
  4. 如果要进行大量的随机访问，就使用ArrayList；如果要经常从表中间插入或删除元素，则应该使用LinkedList.
  5. 各种Queue以及栈的行为，由LinkedList提供支持。
  6. Map是一种将对象(而非数字)与对象相关联的设计。HashMap设计用来快速访问；而TreeMap保持“键”始终处于排序状态，所以没有HashMap快。LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问能力。
  7. Set不接受重复元素。HashSet提供了最快的查询速度，而TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保存元素。
  8. 新程序中不应该使用过时的Vetor、Hashtable和Stack

![简单容器的分类](C:\Users\Maktub\Desktop\photo\简单容器的分类.png)

