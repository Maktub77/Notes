[TOC]

### 跳表

* 链表加多级索引的结构，使其支持类似“二分”的查找算法，就是跳表

  ![1551318584397](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/跳表.png)

* 跳表中查询任意数据的时间复杂度就是O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找。

* 不过查询效率的提升，前提是建立了很多级索引，也就是空间换时间的思路。

* 跳表的空间复杂度为O(n)

* 降低索引占用的内存空间

  * 每三个到五个结点，抽一个结点到上级索引
  * 空间复杂度还是O(n)，但结点存储空间会变少很多

  > 实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。

高效的动态插入和删除

* 在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)
* 如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单
  链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删
  除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题
  了

跳表索引动态更新

* 当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表

  ![1551319256104](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/跳表索引动态更新.png)

* 我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中，以维持索引与原始链表之间的平衡

  * 通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K ，那我
    们就将这个结点添加到第一级到第 K 级这 K 级索引中。

  ![1551319393318](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/跳表索引动态更新_.png)

----

#### 为什么Redis要用跳表来实现有序集合而不是红黑树

* Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。

*  Redis 中的有序集合支持的核心操作主要有下面这几个：

  * 插入一个数据；
  * 删除一个数据；
  * 查找一个数据；
  * 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；
  * 迭代输出有序序列。

  ​        其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。

  ​	对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。

  ​	当然， Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

  ​	不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。