[TOC]

### 递归

* 递归是一种非常高效、简洁的编码技巧，一种应用比较广泛的算法，例如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。
* 方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。
* 基本上，所有的递归问题都可以用递推公式来表示，例如` f(n) = f(n-1)+f(n-2)`

优点：

* 代码的表达能力强，写起来简洁

缺点：

* 空间复杂度高

* 有堆栈溢出风险

  * 函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

  * 通过在代码中限制递归调用的最大深度的方式来解决——当递归调用到一定深度之后，就不再继续往下递归了，直接返回报错。（只适合规模比较小的情况）

    > 若规模较大——自己模拟一个栈 用非递归代码实现。

* 存在重复计算

  * 为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过得f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算

    ```java
    public int f(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        // hasSolvedList 可以理解成一个 Map ， key 是 n ， value 是 f(n)
        if (hasSolvedList.containsKey(n)) {
            return hasSovledList.get(n);
        }
        int ret = f(n-1) + f(n-2);
        hasSovledList.put(n, ret);
        return ret;
    }
    ```

* 过多的函数调用会耗时较多等

-----

使用递归应该满足一下三个条件：

1. 问题的解可以分解为几个子问题（数据规模更小的问题）的解
2. 问题与子问题的求解思路完全一样
3. 存在递归终止条件

---

递归的实现

* 写递推代码的关键
  1. 找到如何将大问题分解为小问题的规律，写出递推公式；
  2. 推敲终止条件；
  3. 将递推公式和终止条件翻译为代码。
* 递归代码的理解
  * 不要试图想清楚整个递和归的过程
  * 不需要深入思考子问题之后每一层的关系，屏蔽掉递归细节
  * 理解递归公式，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

----

递归代码改为非递归代码

* 基本上，所有的递归代码都可以改写为迭代循环的非递归写法。
* 抽象出递推公式、初始值和边界，然后用迭代循环实现

----

递归代码的调试方法

* 打印日志发现递归值
* 结合条件断点进行调试
  * IDEA——Debug——Condition