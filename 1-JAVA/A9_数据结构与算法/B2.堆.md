[TOC]

### 堆

* 堆是一个完全二叉树
* 堆中每一个节点的值都必须大于等于（或小于等于）其子树节点的值
  * 每个节点大于等于子树中每个节点的堆叫做“大顶堆”
  * 每个节点小于等于子树中每个节点的堆叫做“小顶堆”

##### 如何实现一个堆

使用数组存储堆，数组下标为i的节点的左子节点，就是下标为i+2的节点，右子节点就是下标为i*2+1的节点

![1551921776091](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/堆.png)

* 插入

  * 新插入的元素放在堆的最后

  * 然后需要进行调整，使其满足堆的特性，这个过程叫做“堆化”

    顺着节点所在的路径，向上或者向下，对比，然后交换。

    ![1551922173316](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/堆化.png)

    ```java
    public class Heap {
        private int[] a; // 数组，从下标1开始存储数据
        private int n; // 堆可以存储的最大数据个数
        private int count; // 堆中已经存储的数据个数
        public Heap(int capacity) {
            a = new int[capacity + 1];
            n = capacity;
            count = 0;
        }
        public void insert(int data) {
            if (count >= n) return; // 堆满了
            ++count;
            a[count] = data;
            int i = count;
            while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
                swap(a, i, i/2); // swap()函数作用：交换下标为i和i/2的两个元素
                i = i/2;
            }
        }
    }
    ```

* 删除堆顶元素

  * 堆顶元素存储的就是堆中数据的最大值或者最小值

  * 假设我们构造的是大顶堆，堆顶元素就是最大值。当堆顶元素删除后，我们就把第二大的元素放在堆顶，依次类推——这种方法，最后堆化出来的堆并不满足完全二叉树的特性

  * 解决：堆顶元素删除后，将最后一个节点放在堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，就互换，并且重复这个过程，直到父子节点之间满足大小关系

    因为我们移除的是数组的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化的结果，肯定满足完全二叉树的特性

    ```java
    public void removeMax() {
        if (count == 0) return -1; // 堆中没有数据
        a[1] = a[count];
        --count;
        heapify(a, count, 1);
    }
    
    private void heapify(int[] a, int n, int i) { // 自上往下堆化
        while (true) {
            int maxPos = i;
            if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
            if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
            if (maxPos == i) break;
            swap(a, i, maxPos);
            i = maxPos;
        }
    }
    ```

  一个包含n个节点的完全二叉树，树的高度不会超过log~2~n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以时间复杂度都是O(logn)

##### 基于堆实现排序

* 建堆

  1. 在堆中插入一个元素——假设起初堆中只包含一个元素，就是下标为1的数据。然后调用插入操作，将数据依次插入到堆中，这样就组织成了包含n个数据的堆（从前往后处理数据）

  2. 从后往前处理数组，并且每个数据都是从上往下堆化

     对下标从n/2开始到1的数据进行堆化，下标是n/2 + 1到n的节点是叶子节点，不需要堆化

  > 对于完全二叉树来说，下标从n/2 + 1到n的节点都是叶子节点

  建堆的时间复杂度为O(n)

  ```java
  private static void buildHeap(int[] a, int n){
      for(int i = n/2; i >= 1; --i){
          heapify(a,n,i);
      }
  }
  
  private static void heapify(int[] a, int n, int i){
      while(true){
          int maxPos = i;
          if(i*2 <= n && a[i] < a[i*2])maxPos = i*2;
          if(i*2 + 1 <= n && a[maxPos] < a[i*2+1])maxPos = i*2+1;
          if(maxPos == i)break;
          swap(a, i, maxPos);
          i = maxPos;
      }
  }
  ```

* 排序

  * 大顶堆，数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为n的位置

  * 这个过程类似“删除栈顶元素”的操作，当堆顶元素移除后，将下标为n的元素放在堆顶，然后再通过堆化的方法，将剩下的n-1个元素重新构建成堆。堆化之后，再取堆顶元素，放下下标为n-1的位置，一直重复这个过程，直到堆中只剩下标为1的一个元素，排序就完成了

    ```java
    public static void sort(int[] a, int n){
        buildHeap(a, n);
        int k = n;
        while(k > 1){
            swap(a, 1, k);
            --k;
            heapify(a, k ,1);
        }
    }
    ```

  > 堆排序是不稳定的，时间复杂度为O(n/logn)的原地排序算法。

##### 为什么快速排序要比堆排序性能好？

1. 堆排序数据访问的方式没有快速排序友好
   * 快速排序是局部顺序访问的，而堆排序是跳着访问的，对CPU缓存不友好
2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数多于快速排序
   * 对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。
   * 快速排序数据交换的次数不会比逆序度多。
   * 但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。

#### 堆的应用

##### 优先级队列

* 在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队

> 一个堆就可以看作是一个优先级队列，只是概念上的区分

###### 合并有序小文件

* 假设我们有 100 个小文件，每个文件的大小是 100MB ，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件
  * 从100个小文件中分别取出最小的字符串放入到小顶堆中，那堆顶元素，就是优先级队列的队首元素，就是最小字符串；
  * 将这个字符串放入到大文件中，并将其从堆中删除，然后再从被删除字符串所在小文件中取出下一个字符串，放入堆中
  * 循环这个过程，就可以将100个小文件中的数据依次放入到大文件中

###### 高性能定时器

* 假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。
  * 按照任务设定的时间，将这些任务存储在优先级队列中，队首（小顶堆的堆顶）存储的是最先执行的任务
  * 定时器拿队首任务的执行时间点，与当前时间相减，得到一个时间间隔T
  * 这个时间间隔T就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在T秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间，定时器都不要做任何事
  * 当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间

##### 利用堆求TopK

* 静态数据集合
  * 维护一个大小为K的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。
  * 这样等数组遍历完之后，堆中的元素就是前K大数据了
* 动态数据集合
  * 一直维护一个K大小的小顶堆，当有数据被添加到集合中时，我们拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理

##### 利用堆求中位数

* 维护两个堆，一个大顶堆，一个小顶堆；大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆中的数据都大于大顶堆的数据。
* 这样大顶堆的堆顶元素就是中位数
* 当添加一个数据时
  * 如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新的数据插入到大顶堆
  * 如果新加入的数据大于等于小顶堆的堆顶元素，我们就将这个新的数据插入到小顶堆
* 这个时候，两个堆中的数据个数不符合约定的情况
  * 可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足约定

![1551940187066](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/堆求中位数.png)

###### 扩展

* 利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理与求中位数类似

  ![堆求中位数拓展](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/堆求中位数拓展.png)



