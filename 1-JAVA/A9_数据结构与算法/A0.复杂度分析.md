[TOC]

### 复杂度分析

**时间复杂度**（Complexity）：可以量化（通过数学公式）起始条件与算法执行的时间之间的关系

* 时间复杂度：T(n)=O(f(n)) 

- 复杂度是算法渐进行为的度量
- 大O标记法中，可以省略掉系数、低阶、常量

> 最坏情况（Worst Case）：在计算算法复杂度时，可以认为给定的输入对于我们的算法来说是处于最坏情况

1. **只关注循环执行次数最多的一段代码**

2. **加法法则**：总复杂度等于量级最大的那段代码的复杂度

   如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ； 

   那么T(n)=T1(n)+T2(n)=max(O(f(n))；

    O(g(n))) =O(max(f(n),g(n)))

   >  m 和 n 是表示两个数据规模，无法判定大小则加法法则改为
   >
   >  T1(m) + T2(n) = O(f(m) +g(n))

3. **乘法法则**：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

   如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)\*T2(n)=O(f(n))\*O(g(n))=O(f(n)*g(n)).

**空间复杂度**

- 渐进空间复杂度，表示算法存储空间与数据规模之间的增长关系

* 空间复杂度：S(n)=O( f(n) )   

#### 常见算法时间复杂度之间的关系

- O(1)<O(logn)<O(n)<O(nlog n)<O(n^2)<O(n!)  

![1550541003899](C:\Users\Maktub_J\Documents\Notes\0-picture\数据结构与算法/复杂度分析.png)

----

为了表示同一代码在不同情况下的不同时间复杂度

* 最好情况时间复杂度

* 最坏情况时间复杂度

* 平均情况时间复杂度（加权平均时间复杂度或者期望时间复杂度）

  * 要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0 ～ n-1 位置中和不在数组中。

    我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1 ，就可以得到需要遍历的元素个数的平均值

均摊时间复杂度

* 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块分析，看是否能够将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度的分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。