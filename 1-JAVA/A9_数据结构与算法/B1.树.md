[TOC]

### 树（Tree）

![1551748488883](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/树.png)

* A 节点就是 B 节点的父节点， B 节点是 A 节点的子节点。
*  B 、 C 、 D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。
* 我们把没有父节点的节点叫作根节点，也就是图中的节点 E 。
* 我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的 G 、 H 、 I 、J 、 K 、 L 都是叶子节点。

![1551748604251](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/树的高度深度、层.png)

#### 二叉树（Binary Tree）

* 每个节点最多有两个“叉”，也就是两个节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的只有左节点，有的只有由节点。

  ![1551748915008](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/二叉树.png)

* 编号2的二叉树中，叶子节点全都在最底层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。

* 编号3的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大，这种二叉树叫作完全二叉树。

  ![1551749265948](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/完全二叉树.png)

如何表示（或者存储）一颗二叉树？

* 基于指针或者引用的二叉链式存储法

  ![1551749376317](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/二叉链式存储法.png)

  * 每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树串起来

  ```java
  
  ```

* 基于数组的顺序存储法

  * 根节点存储在下标i = 1的位置，那左字节点存储在下标2\*i=2的位置，右子节点存储在2\*i +1=3的位置。

  * 以此类推， B 节点的左子节点存储在 2 * i= 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置

    ![1551749904622](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/顺序存储法.png)

    ```java
    
    ```

* 如果某棵二叉树是一颗完全二叉树，哪用数组来存储是最节省内存的一种方式。因为数组的存储不需要像链式存储法一样，要存储额外的左右子节点指针

  > 堆其实就是一种完全二叉树，最常用的存储方式就是数组

##### 二叉树遍历

![1551750141600](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/二叉树遍历.png)

* 前序遍历——对于树的任意结点来说，先打印这个结点，然后再打印它的左子树，最后打印它的右子树
* 中序遍历——对于数的任意结点来说，先打印这个结点的左子树，然后打印它本身，最后打印它的右子树
* 后序遍历——对于数的任意结点来说，先打印它的左子树，然后打印它的右子树，最后打印这个结点本身、

> 前中后序遍历时间复杂度都为O(n)

##### 二叉查找树（Binary Search Tree）

* 二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树

* 在树中的任意一个结点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值
* 查找
* 插入
* 删除
* 快速查找最大和最小结点、前驱结点和后继结点
* 支持重复数据的二叉查找树

​        在二叉查找树中，查找、插入、删除等很多操作的时间都跟树的高度成正比。两个极端情况的时间复杂度分别是O(n)和O(logn)，分别对应二叉树退化成链表的情况和完全二叉树

​	为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树，平衡二叉查找树，时间复杂度可以做到稳定的O(logn)

---

有了如此高效的散列表，为什么还需要二叉树？

1. 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在O(n)的时间复杂度内，输出有序的数据序列
2. 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉树的性能非常稳定，时间复杂度稳定在O(logn)
3. 笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比O(logn)快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高
4. 散列表的构造比二叉树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决的办法、扩容、缩容等。平衡二叉树只需要考虑平衡性这一问题，而且这个问题的解决方案比较成熟、固定
5. 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间

#### 红黑树

* 二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于log 2 n的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n) 。要解决这个复杂度退化的问题，我们需要设计一种**平衡二叉查找树**。

* 平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于1。
* 最先被发明的平衡二叉树是AVL树，它严格符合平衡二叉树的定义，是一种高度平衡的二叉查找树
* 如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比log 2 n大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。

----

* R-B Tree：它是一种不严格的平衡二叉树
* 定义
  * 红黑树的节点，一类被标记为黑色，一类被标记为红色
  * 根节点是黑色的
  * 每个叶子节点都是黑色的空节点（NIL）,叶子节点不存储数据
  * 任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的
  * 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点
* 省略黑色的、空的叶子节点

![红黑树](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/红黑树.png)

###### 为什么说红黑树是“近似平衡”的？

* 二叉查找树的很多操作的性能都跟树的高度成正比。一颗及其平衡的二叉树（满二叉树或完全二叉树）的高度大约是log~2~n，所以要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近log~2~n
  * 删除红色节点
  * 二叉树变为四叉树（从任意结点到可达叶子节点的每个路径包含相同数目的黑色节点）仅包含的黑色节点的四叉树的高度<相同节点个数的完全二叉树的高度（log~2~n）
  * 将红色节点加回去
  * （红黑树中，红色节点不能相邻）红黑树的高度近似2log~2~n
* 因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它

---

###### 为什么在工程中大家都喜欢用红黑树这种平衡二叉查找树？

* Treap、Splay Tree ，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用
* AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊， AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了
* 红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低
* 红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，更倾向于这种性能稳定的平衡二叉查找树

---

##### 红黑树的平衡调整

* 左旋、右旋，围绕某个节点左旋、右旋

  ![1551840909729](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/红黑树-左旋_右旋.png)

* 把红黑树的平衡调整的过程比作魔方复原，不要深究算法的正确性；只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了

* 找准关注节点，不要搞丢、搞错关注节点。

* 针对删除操作，两次调整

  1. 第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义， “ 每个节点到可达叶子节点的路径都包含相同个数的黑色节点 ” 。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。
  2. 解决这个问题，让红黑树不存在相邻的红色节点。

###### 为什么红黑树的定义中，要求叶子节点是黑色的空节点？

* 为了实现方便

* 具体实现时，共用同一个叶子节点NIL

  ![1551841550827](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/叶子节点NIL.png)

#### 递归树

##### 借助树来求解递归算法的时间复杂度