[TOC]

### 排序

排序算法的执行效率

1. 最好情况、最坏情况、平均情况时间复杂度
   * 有些排序算法会区分这三种时间复杂度，为了好对比，所以我们最好都做一下区分
   * 对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。
2. 时间复杂度的系数、常数、低阶
   * 在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。
3. 比较次数和交换（移动）次数
   * 比较元素大小，和元素交换或移动

排序算法的内存消耗

* 原地排序：特指空间复杂度O(1)的排序算法。(插入、冒泡、选择)

排序算法的稳定性

* 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

---

#### 小规模数据的排序

##### 冒泡排序

```java
public void bubbleSort(int[] arr, int n){
    if(n <= 1)return;

    for(int i = 0; i < n; i++){
        //提前退出循环标志位
        boolean flag = false;
        for(int j = 0; j < n - i - 1; ++j){
            if(arr[j] > arr[j+1]){
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
                flag = true;    //有数据交换
            }
        }
        if(!flag)break; //没有数据交换,提前退出
    }
}
```

1. 冒泡排序是原地排序算法吗？

   * 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1) ，是一个原地排序算法。

2. 冒泡排序是稳定的排序算法吗？

   * 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法

3. 冒泡排序的时间复杂度是多少？

   * 最好情况：O(n)

   * 最坏情况：O(n^2)

   * 平均：O(n^2)

     * 有序度：具有有序关系的元素对的个数

       ```
       有序元素对： a[i] <= a[j], 如果 i < j 
       ```

     * 对于一个完全有序的数组 ，有序度就是 n*(n-1)/2。我们把这种完全有序的数组的有
       序度叫作满有序度。

     * 逆序度

       ```
       逆序元素对： a[i] > a[j], 如果 i < j
       ```

     * 逆序度 = 满有序度 - 有序度

   * 排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了

##### 插入排序

```java
public void insertionSort(int[] arr, int n){
    if(n <= 1)return;
    for (int i = 1; i < n; i++){
        int value = arr[1];
        int j = i - 1;
        //查找插入的位置
        for(; j <= 0; --j){
            if(arr[j] >value){
                arr[j+1] = arr[j]; //数据移动
            }else{
                break;
            }
        }
        arr[j+1] = value; //插入数据
    }
}
```

1. 插入排序是原地排序算法吗？
   * 从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1) ，也就是说，这是一个原地排序算法。
2. 插入排序是稳定的排序算法吗？
   * 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
3. 插入排序的时间复杂度是多少？
   * 最好情况：O(n)
   * 最坏情况：O(n^2)
   * 平均：O(n^2)

##### 选择排序

```java

```

1. 选择排序是原地排序算法吗？
   - 空间复杂度是O(1)，这是一个原地排序算法。
2. 选择排序是稳定的排序算法吗？
   - 插入排序不是稳定的排序算法。
3. 选择排序的时间复杂度是多少？
   - 最好情况：O(n^2)
   - 最坏情况：O(n^2)
   - 平均：O(n^2)

----

冒泡排序和插入排序的时间复杂度都是 O(n ) ，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

* 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。
  但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3个赋值操作，而插入排序只需要 1 个。（希尔排序）

----

#### 大规模数据的排序

##### 归并排序

* 如果要排序一个数组，我们先把数组从中间分成前后两部分，然后前后两部分分别排序，再将排好序的两部分合在一起，这样整个数组就有序了。

  >  归并排序使用的就是分治思想，将大问题分解成小问题来解决。

  > 分治算法一般都是用递归来实现的。

  > 分治是一种解决问题的处理思想，递归是一种编程技巧

  ```
  递推公式：
  merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
  终止条件：
  p >= r 不用再继续分解
  ```

  ```java
  public class MergeSort {
      private static void mergeSort(int[] arr, int small, int big){
          if(small < big){
              int mid = (small + big)/2;
              mergeSort(arr, small, mid);
              mergeSort(arr, mid+1, big);
              merge(arr, small, mid, big);
          }
      }
  
      private static void merge(int[] arr, int small, int mid, int big) {
          int[] tmp = new int[big - small + 1];
          int i = small;
          int j = mid + 1;
          int m = 0;
          while (i <= mid && j <= big){
              if(arr[i] < arr[j]){
                  tmp[m++] = arr[i++];
              }else {
                  tmp[m++] = arr[j++];
              }
          }
  
          while(i <= mid){ //将左边剩余元素填充进temp中
              tmp[m++] = arr[i++];
          }
  
          while(j <= big){  //将右序列剩余元素填充进temp中
              tmp[m++] = arr[j++];
          }
  
          if (tmp.length >= 0){
              System.arraycopy(tmp, 0, arr, small, tmp.length);
          }
      }
  
      public static void main(String[] args) {
  
          int[] test = {9,2,6,3,5,7,10,11,12};
          mergeSort(test,0,test.length-1);
          for (int aTest : test) {
              System.out.print(aTest + " ");
          }
      }
  }
  ```

1. 归并排序是原地排序算法吗？

   - 需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是原地排序 

2. 归并排序是稳定的排序算法吗？

   - 插入排序是稳定的排序算法。

3. 归并排序的时间复杂度是多少？

   - 最好情况：O(nlogn) 
   - 最坏情况：O(nlogn) 
   - 平均：O(nlogn) 

   > 若用单链表做存储结构，很容易给出就地的归并排序

##### 快速排序

* 如果要排序数组中下标p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点)

  我们遍历p到r之间的数据，将小于pivot的放在左边，将大于pivot的放在右边，将privot放在中间。

  根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。

  ```
  递推公式：
  quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)
  终止条件：
  p >= r
  ```

  ```java
  private static void quickSort(int[] arr, int start, int end){
      if(start < end){
          int pivot = partition(arr, start, end);
          quickSort(arr, start, pivot-1);
          quickSort(arr, pivot + 1, end);
      }
  }
  
  private static int partition(int[] arr, int start, int end) {
      int pivot = start - 1;
      int base = arr[end];
      for (int i = start; i < end; i++){
          if(arr[i] <= base){
              pivot++;
              int temp = arr[pivot];
              arr[pivot] = arr[i];
              arr[i] = temp;
          }
      }
      int temp = arr[pivot + 1];
      arr[pivot + 1] = arr[end];
      arr[end] = temp;
      return pivot + 1;
  }
  ```

  1. 快速排序是原地排序算法吗？
     - 是原地排序 
  2. 快速排序是稳定的排序算法吗？
     - 是不稳定的排序算法。
  3. 快速排序的时间复杂度是多少？
     - 最好情况：O(nlogn) 
     - 最坏情况：O(n^2) 
     - 平均：O(nlogn) 

-----

O(n)时间复杂度内求无序数组中的第K大元素

* 选择数组区间A[0...n-1]的最后一个元素作为pivot，对数组A[0...n-1]原地分区，这样数组就分成了三部分，A[0...p-1]，A[p]，A[p+1...n-1]
* 如果p+1=K，那A[p]就是要求解的元素；如果K>p+1,说明第K大元素出现在A[p+1...n-1]区间，我们再按照上面的思路递归在A[p+1...n-1]这个区间内查找。
* 同理，如果K<p+1，那我们就在A[0...p-1]区间查找

---

理解归并排序的重点是理解递推公式和merge()合并函数

理解快速排序的重点是理解递推公式和partition()分区函数

#### 线性排序

* 时间复杂度为O(n)的排序算法
* 做到线性排序的主要原因是，算法是非基于比较的算法，都不涉及元素之间的比较操作

##### 桶排序

* 假设输入数据服从均匀分布，将数据分到有限数量的痛里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）

---

* 桶排序比较适用在外部排序中——就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中

---

* 设置一个定量的数组当作空桶；
* 遍历输入数据，并且把数据一个一个放到对应的桶里去；
* 对每个不是空的桶进行排序；
* 从不是空的桶里把排好序的数据拼接起来

----

```

```

> 桶排序最好情况下使用线性时间O(n),桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 

##### 计数排序

* 计数排序其实是桶排序的一种特殊情况。
* 当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。
* 计数排序要求输入的数据必须是由确定范围的整数

---

* 找出待排序的数组中最大和最小的元素；
* 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
* 对所有的计数累加（从C中的第一个元素楷书，每一项和前一项相加）
* 反向填充目标数组——将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

```java

```

> 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法 

##### 基数排序

* 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。
* 有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 

---

* 取得数组中的最大数，并取得位数；
* arr为原始数组，从最低位开始取每个位组成radix数组；
* 对radix进行计数排序（利用计数排序适用于范围数的特点）

```java

```

> 基数排序对要排序的数据是有要求的，需要可以分割出独立的 “ 位 ” 来比较，而且位
> 之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n) 了

----

##### 小结

​	桶排序和计数排序的排序思想非常相似，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。

----

#### 排序优化

![1551229783021](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/排序算法.png)

* 对小规模的数据进行排序，可以选择时间复杂度是O(n^2)的算法；如果对大规模数据进行排序，时间复杂度是O(nlogn)的算法更加高效

* 为了兼顾任意规模的数据，一般首选时间复杂度是O(nlogn)的排序算法

* 归并排序和快速排序

  * 归并不是原地排序算法，时间复杂度为O(n)
  * 一般选择快速排序；快排最坏情况下时间复杂度为O(n^2)

* 优化快速排序

  为了提高快速排序的性能，我们就要尽可能地让每次分区都比较平均

  * **三数取中法**——从区间的首、尾、中间分别取一个数，然后对比大小，取这三个数的中间值作为分区点

    如果排序的数组比较大，可能要"五数取中"或"十数取中"

  * **随机法**——随机法就是每次从要排序的区间中，随机选择一个元素作为分区点