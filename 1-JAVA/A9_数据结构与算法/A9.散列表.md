[TOC]

### 散列表

* 散列表（Hash Table）来源于数组，他借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。

* 把键转化为数组下标的映射方法就叫做散列函数（Hash函数，哈希函数），而散列函数计算得到的值就叫做散列值（Hash值，哈希值）

  ![1551321546079](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/散列表.png)

* 散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性，我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应的下标的位置。然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据。

##### 散列函数设计

* hash(key)，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值

设计要求

1. 散列函数得到的散列值是一个非负整数
2. 如果key1 = key2，那么hash(key1) == hash(key2);
3. 如果key != key2，那么hash(key1) != hash(key2).

* 散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能

##### 散列冲突解决

* 开放寻址法(open addressing)
  * 如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。
  * 线性探测（Linear Probing）
    * 删除的元素特殊标记为deleted，不能设置为空；当线性探测查找时，遇到标记为deleted的空间，并不是停下来，而是继续往下探测
  * 二次探测（Quadratic proding）
    * 跟线性探测很像，线性探测每次探测的步长是1，而二次探测的步长就变成了原来的“二次方”
  * 双重散列（Double hashing）
    * 意思是不仅使用一个散列函数。我们使用一组散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置，

> 装载因子（load factor）来表示散列表中空位的多少——装载因子越大，空闲位置越少，冲突越多，散列表的性能会下降
>
> ```
> 散列表的装载因子 = 填入表中的元素个数/散列表的长度
> ```

* 链表法(chaining)

  ![1551332621965](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/散列-链表法.png)

  在散列表中，每个“桶（bucket）”或者"槽（slot）"会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

  当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所
  以插入的时间复杂度是 O(1) 。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，
  然后遍历链表查找或者删除。

----

#####  Word 文档中单词拼写检查功能是如何实现的？

​	常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB 。对于现在
的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。
	当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正
确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。

---

##### 如何设计散列函数？

* 散列函数的设计不能太复杂——提高效率
* 散列函数生成的值要尽可能随机并且均匀分布——避免冲突
* 设计方法
  * 数据分析法
  * 直接寻址法、平方取中法、折叠法、随机数法

##### 装载因子过大怎么办？

* 针对散列表，当装载因子过大时，我们也可以进行**动态扩容**，重新申请一个更大的散列表，将数据搬移到这个新散列表中
* 当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重

##### 如何避免低效地扩容？

* 为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。
* 当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中
* 当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。
* 经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。
* 这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。

##### 如何选择冲突解决方法？

* 开放寻址法
  * 优点
    * 存储在数组中，能有效地利用CPU缓存加快查询速度
    * 序列化起来比较简单
  * 缺点
    * 解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据
    * 所有的数据都存储在一个数组中，冲突的代价更高
    * 使用开放寻址法解决冲突的散列表，装载因子的上限不能太大——导致这种方法比链表法更浪费内存空间
  * 当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java中的ThreadLocalMap使用来访寻址法解决散列冲突的原因
* 链表法
  * 优点
    * 对内存的利用率比开放寻址法更高
    * 对大装载因子的容忍度更高
  * 缺点
    * 链表因为要存储指针，所以对于比较小的对象的存储，是比
      较消耗内存的，还有可能会让内存的消耗翻倍。
    * 链表中的结点是零散分布在内存中的，
      不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响
  * 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更灵活，支持更多的优化策略，比如红黑树代替链表。

##### HashMap散列表分析

1. 初始大小

   * HashMap默认的初始大小是16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高HashMap的性能。

2. 装载因子和动态扩容

   * 最大装载因子默认是0.75，当HashMap中元素个数超过0.75*capacity（capacity表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。

3. 散列冲突解决方法

   * HashMap底层采用链表发来解决冲突。
   * 当链表长度太长（默认超过8）时，链表就转换为红黑树。我们可以根据红黑数快速增删改查的特点，提高HashMap的性能。
   * 当红黑树结点个数少于8个的时候，又会将红黑树转化为链表——因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。

4. 散列函数

   * 散列函数设计并不复杂，追求的是简单高效、分布均匀

     ```java
     static final int hash(Object key) {
         int h;
         return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
     }
     ```

   * hashCode() 返回的是 Java 对象的 hash code 。比如 String 类型的对象的hashCode() 就是下面这样：

     ```java
     public int hashCode(){
         int var1 = this.hash;
         if(var1 == 0 && this.value.length > 0) {
             char[] var2 = this.value;
             for(int var3 = 0; var3 < this.value.length; ++var3) {
                 var1 = 31 * var1 + var2[var3];
             }
             this.hash = var1;
         }
         return var1;
     }
     ```

---

##### 何为一个工业级的散列表？工业级的散列表应该具有哪些特性？

要求

* 支持快速的查询、插入、删除操作
* 内存占用合理、不能浪费过多的内存空间
* 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况

实现

* 设计一个合适的散列函数
* 定义装载因子阈值，并且设计动态扩容策略
* 选择合适的散列冲突解决方法

结合具体的业务场景、具体的业务数据来具体分析

----

##### 为什么散列表和链表经常会一起使用？

* 散列表这种数据结构虽然支持非常高效的数据插入、删除、查询操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就是说，它无法支持按照某种顺序快速地遍历数据。
* 如果希望按照顺序遍历散列表中的数据，我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历
* 因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或跳表）结合在一起使用。

###### LRU缓存算法

一个缓存（cache）系统主要包含以下操作

* 往缓存中添加一个数据；
* 从缓存中删除一个数据；
* 在缓存中查找一个数据。

![1551662331499](C:\Users\Maktub\Documents\Notes\0-picture\数据结构与算法/LRU缓存算法.png)

* 使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）、hnext指针
* 因为散列表示通过链表法解决散列冲突的，所以每个节点会在两条链中；一条链是双向链表，另一条链式散列表中的链
* 前驱和后驱指针是为了将结点串在双向链表中，hnext指针是为了将结点串在散列表的拉链中

###### Redis有序集合

Redis有序集合的操作

* 添加一个成员对象；
* 按照键值来删除一个成员对象；
* 按照键值来查找一个成员对象；
* 按照分值区间查找数据；
* 按照分值从小到大排序成员变量。

我们可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1) 。同时，借助跳表结构，其他操作也非常高效。

###### LinkedHashMap

* 按照访问时间排序
* 本身是一个支持LRU缓存淘汰策略的缓存系统，原理相同
* 通过双向链表和散列表这两种数据结构组合实现