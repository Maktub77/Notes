### 介绍GC日志

GC日志是一个很好的信息来源，他对性能问题的"冷案例"分析特别有用，例如提供对崩溃发生原因的一些了解。即使没有实时应用程序进行诊断，它也可以让分析师工作。

每个重要的应用应始终：

* 生成GC日志
* 将其保存在与应用程序输出不同的文件中

对于生产应用尤其如此。正如我们将看到的，GC日志记录没有真正的可观察开销，因此对于任何重要的JVM进程应该始终处于开启状态。

### 打开GC日志

首先要做的是在应用程序启动时添加一些开关。这些最好被认为是"强子GC日志标记"，任何Java/JVM应用程序（可能是桌面应用程序除外）都应该使用它们。标志是：

```properties
-Xloggc:gc.log
-XX:+PrintGCDetails
-XX:+PrintTenuringDistribution
-XX:+PrintGCTimeStamps
-XX:+PrintGCDateStamps
```

让我们更详细地看一下这些标志。它们的用法如表所示

| Flag                           | effect                                   |
| ------------------------------ | ---------------------------------------- |
| -Xloggc:gc.log                 | GC事件记录文件                           |
| -XX:+PrintGCDetails            | 记录GC事件详情                           |
| -XX:+PrintTenuringDistribution | 添加对工具至关重要的额外GC事件细节       |
| -XX:+PrintGCTimeStamps         | 打印发生GC事件的时间（自VM启动后的秒数） |
| -XX:+PrintGCDateStamps         | 打印GC事件发生的挂钟时间                 |

 性能工程师应该注意一下有关这些标志的详细信息：

* PrintGCDetails标志替换旧的详细信息：gc。应用程序应删除旧标志
* PrintTenuringDistribution标志与其他标志不同，因为它提供的信息不容易被人类直接使用。该标志提供计算关键内存压力效果和事件（如过早晋升）所需的原始数据
* PrintGCDateStamps和PrintGCTimeStamps都是必需的，因为前者用于将GC事件与应用程序事件（在应用程序日志文件中）相关联，后者用于关联GC和其他内部JVM事件。 

这种级别的日志记录细节不会对JVM的性能产生可测量的影响。当然，生成的日志量取决于许多因素，包括分配率，使用中的收集器和堆大小（更频繁地需要更小的堆，因此将更快地生成日志）

为了给你一些注意，模型分配器示例的30分钟运行在30分钟的运行中产生约600KB的日志，每秒分配50MB.

除了强制标志之外，还有一些控制GC日志轮换的标志，许多应用程序支持团队认为这些标志在生产环境中很有用

| Flag                              | effect                       |
| --------------------------------- | ---------------------------- |
| `-XX：+ UseGCLogFileRotation`     | 切换日志文件轮换             |
| `-XX：+ NumberOfGCLogFiles = <N>` | 设置要保留的最大日志文件数   |
| `-XX：+ GCLogFileSize = <大小>`   | 设置旋转前每个文件的最大大小 |

 建立合理的日志轮换策略应该与操作人员（包括devops）一起完成。

### GC Logs与LMX

在"JVM的监视和工具中"，我们遇到了VisualGC工具，它能够显示JVM堆状态的实时视图。该工具实际上依赖于Java Management eXtensions（JMX）接口来从JVM收集数据。就JMX对GC的影响而言，性能工程师应了解一下内容：

* GC日志数据由实际垃圾收集事件驱动，而JMX源数据通过抽样获得
* GC日志数据对捕获的影响极小，而JMX具有隐式代理和远程方法调用（RMI）成本
* GC日志数据包含于Java内存管理相关的50多个性能数据方面，而JMX少于10个

传统上，JMX作为性能数据源的日志的一个优点使JMX可以提供开箱即用的流数据。但是，jClarity Censum等现代工具 提供了API来传输GC传统日志数据，缩小了这一差距

> 警告：对于基本使用情况的粗略趋势分析，JMX是一个相当快速和简单的解决方案；然而，为了更深入地诊断问题，它很快就会表得不足

通过JMX提供的bean是一种标准，易于获取。VisualVM工具提供了一种可视化数据的方法，市场上还有许多其他工具可供使用

### JMX的缺点

使用JMX监视应用程序的客户端通常依赖于运行时进行采样以获取当前状态更新。要获得连续的数据提要，客户端需要在该运行时中轮询JMX bean

在垃圾手机的情况下，这会导致问题：客户端无法知道收集器何时运行。这意味着每个收集周期之前和之后的内存状态是未知的。这排除了对GC数据执行一系列更深入，更准确的分析技术。

基于JMX数据的分析仍然有用，但仅限于确定长期趋势。但是，如果我们想要准确地调整垃圾收集器，我们需要做得更好。特别是，能够在每次收集之前和之后理解堆的状态是非常有用的。

此外，围绕内存压力（即分配率）存在一组及其重要的分析，由于从JMX收集数据的方式，这些分析根本不可能。

不仅如此，JMXConnector规范的当前实现还依赖于RMI。因此，JMX的使用受到与任何基于RMI的通信信道相同的问题的影响。这些包括：

* 在防火墙中打开端口，以便建立辅助套接字连接、
* 使用代理对象来方便remove()方法调用
* 对Java finalization的依赖

对于一些RMI连接，关闭连接所涉及的工作量是微不足道的。然而，拆解依赖于finalization。这意味着垃圾手机器必须运行以回收对象。

JMX连接的生命周期的性质意味着，通常这将导致在完整GC之前不收集RMI对象。

默认情况下，任何使用RMI的应用程序都会导致每小时触发一次完整的GC.对于已使用RMI的应用程序，使用JMX不会增加成本。但是，如果他们决定使用JMX，那么尚未使用RMI的应用程序必然会收到额外的打击。

### GC日志数据的好处

现代垃圾收集器包含许多不同的移动部件，这些部件放在一起会导致及其复杂的实施。如此复杂的是，即使不是不可能预测，收集器的性能似乎也很难实现。这些类型的软件系统被称为emergent，因此它们的最终行为和性能是所有组件如何一起工作和执行的结果。不同的压力以不同的方式对不同的组件施加压力，导致非常流动的成本模型。

最初，Java的GC开发成员添加了GC日志记录以帮助调试他们的实现，因此，由近60个GC相关标志生成的大部分数据用于性能调试

随着时间的推移，那些负责调整其应用程序中的垃圾收集过程的人开始认识到，鉴于调整GC的复杂性，他们也可以从运行时发生的事情中获得精确的图像。因此，能够收集和读取GC日志现在是任何调整制度的工具部分。

>提示：GC日志记录是使用非阻塞写入机制在HotSpot JVM中完成的。它对应用程序性能约有0%的影响，应该为所以生产应用程序打开

由于GC日志中的原始数据可以固定到特定的GC事件，我们可以对其进行各种有用的分析，这可以让我们深入了解收集的成本，从而那些调整操作更有可能产生积极的结果

### 日志解析工具

GC日志消息没有语言或VM规范标准格式。这样就可以将任何打个消息的内容留给HotSpot GC开发团队。

事实上，尽管最简单的日志格式易于解析，但由于添加了GC日志标记，因此结果日志输出变得更加复杂。对于并发收集器生成的日志尤其如此。

通常，在对GC配置进行更改后，手动GC日志解析器的系统会在某个时刻出现中断，这会改变日志输出格式。当中断调查转向检查GC日志时，团队发现自制解析器无法处理更改的日志格式-在日志信息最有价值的确切时间点失败。

> :warning:建议开发人员不要尝试自己解析GC日志。相反，应该使用工具

#### Censum

censum内存分析器是jClarity开发的商业工具。它既可以作为桌面工具（用于单个JVM的实际分析），也可以作为监视服务（适用于大型JVM组）。该工具的目的是提供最佳的GC日志解析，信息提取和自动分析。

#### GCViewer

##### 基本GC调优

当工程师考虑调整JVM策略时，经常会出现"我应该合适调整GC?"的问题。与任何其他调整技术一样，GC调整应构成整个诊断过程的一部分。关于GC调整的一下事实非常有用：

* 消除或确认GC是导致性能问题的原因很便宜
* 在UAT中打开GC标准很便宜
* 设置内存或执行分析器并不便宜

工程师还应该知道在调整过程中应该研究和测量者四个主要因素：

* 分配
* 暂停敏感度
* 吞吐量行为
* 对象寿命

其中，分配往往是最重要的

>注意：吞吐量可能受许多因素的影响，例如并发收集器在运行时占用核心

 GC堆大小标记

| 标志                          | 影响                                  |
| ----------------------------- | ------------------------------------- |
| `-Xms<size>`                  | 设置为堆保留的最小大小                |
| `-Xmx<size>`                  | 设置为堆保留的最大大小                |
| `-XX:MaxPermSize=<size>`      | 设置PermGen允许的最大大小（Java 7）   |
| `-XX:MaxMetaspaceSize=<size>` | 设置Metaspace允许的最大大小（Java 8） |
| `-Xms<size>`                  | 设置为堆保留的最小大小                |

 MaxPermSize标志是遗留的，仅适用于Java 7及之前的版本。在Java 8及更高版本中，PermGen已被删除并被Metaspace取代。

> 注意：如果要在Java 8应用程序上设置MaxPermSize，则应该删除该标志。无论如何，它被JVM忽略了，所以它显然对你的应用程序没有影响

关于调整的其他GC标志的主题：

* 一次只添加一个标记
* 确保您完全理解每个标志的效果
* 回想一些组合会产生副作用

假设事件正在发生，检查GC是否是导致性能问题的原因相对容易。第一步是使用vmstat或类似工具查看机器的高级指标，如“基本检测策略”中所述。首先，登录到具有性能问题的框并检查：

* CPU利用率接近100%
* 绝大多数时间（90%+）用于用户空间
* GC日志显示活动，表示GC当前正在运行

这假设问题正在发生，工程师可以实时观察，对于过去的事件，必须提供足够的历史监控数据（包括CPU利用率和具有事件戳的GC日志）

如果满足所有这三个条件，则应调查并调整GC作为当前性能问题的最可能原因。测试非常简单，并且有一个很好的清晰结果-“GC没问题”或“GC不正常”

“如果GC被指示为性能问题的根源，那么下一步是了解分配和暂停时间行为，然后调整GC并在需要时可能带出内存分析器。

####  了解分配

分配率分析不仅对于确定如何调整垃圾收集器非常重要，而且对于是否可以实际调整垃圾收集器以帮助提高性能也很重要

我们可以使用年轻代收集事件中的数据来计算分配的数据量和两个集合之间的时间。然后，该信息可用于计算该时间间隔期间的平均分配率

> 注意：与其花费时间和精力来手动计算分配率，通常最好使用工具来提供此数字

经验表明，持续分配率大于1GB/s几乎总是表明无法通过调整垃圾收集器来纠正的性能问题。在这些情况下提高性能的唯一方法是通过重构来消除应用程序关键部分的分配，从而提高应用程序的内存效率

